{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2026-02-22T01:27:38.792674+00:00",
  "repo": "wilaw/dts4moq",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "I_kwDOROSEss7rKj18",
      "title": "What happens when publisher sends PUBLISH_DONE?",
      "url": "https://github.com/wilaw/dts4moq/issues/2",
      "state": "OPEN",
      "author": "zafergurel",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It is not clear about what happens when the original publisher sends a PUBLISH_DONE message for a track in a switching set.\nPresumably, the relay should take it out from the switching set and decide which track to send to the subscriber.",
      "createdAt": "2026-02-16T01:26:00Z",
      "updatedAt": "2026-02-16T01:26:13Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 3,
      "id": "I_kwDOROSEss7rKmDy",
      "title": "DTS-ACTIVATION in PUBLISH message",
      "url": "https://github.com/wilaw/dts4moq/issues/3",
      "state": "OPEN",
      "author": "zafergurel",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The text says \"DTS is enabled and disabled by the subscriber\" but the rules are defined by either the subscriber or the original publisher. However, there is nothing in the text that explains how a publisher can set the rules. If it can, the most appropriate message would be PUBLISH IMHO. Also, this makes the use of the word \"client\" reasonable.\n",
      "createdAt": "2026-02-16T01:30:27Z",
      "updatedAt": "2026-02-16T01:30:27Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 5,
      "id": "I_kwDOROSEss7rqbTb",
      "title": "remove a track from a switching set",
      "url": "https://github.com/wilaw/dts4moq/issues/5",
      "state": "OPEN",
      "author": "gwendalsimon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "When reading the text, I struggled to understand the sentence \"_The value zero is reserved to indicate no switching set._\" in the definition of the switching set. It becomes clearer when reading the paragraph \"_To remove one track from a switching set, while leaving the other tracks active, the client issues a REQUEST_UPDATE message with the request ID referencing the subscription it wishes to remove and a SWITCHING-SET-ASSIGNMENT parameter with a Switching set ID of zero._\" If we maintain this process, then the first sentence may be rewritten.\n\nThat being said, one track can belong to multiple switching sets, can't it? If the Relay receives a switching set 0, should it remove the track from all switching sets? It may be cleaner to have another parameter SWITCHING-SET-STOP-ASSIGNMENT with only the switching set ID.",
      "createdAt": "2026-02-17T17:02:59Z",
      "updatedAt": "2026-02-17T17:02:59Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOROSEss7ruzBd",
      "title": "Limitations of timer-based definition of synchronized tracks",
      "url": "https://github.com/wilaw/dts4moq/issues/6",
      "state": "OPEN",
      "author": "gwendalsimon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "(As for the SWITCH message), we need a definition of \"common group boundaries\" for a pair of tracks. I think there is a consensus on a definition such as \"_groups with the same ID arriving approximately at the same time_\". Yet, timer-based approach has some limitations:\n- The Subscriber must set a timeout although it does not know the size of the group, nor the objects. Ex: If the first object of a group takes in average 1 sec to be transmitted, then 200 ms may be acceptable, but it would not be for a small group taking say 50ms to be delivered.\n- The Subscriber does not know the Relay upstream connection. In case of significant jitter (for example due to long RTT and non-negligible packet losses), the timer should be increased.\n- If the upstream connection is congested, then the track with the minimum bitrate arrives first, maybe by a far margin. In that case, all other high-quality tracks will be unselected because they arrive too late at the Relay.\n\nIt could be possible to ignore the \"approximately at the same time\" to define common group boundaries. We trust the fact that the Subscriber indicated that these tracks are in sync. So if the Relay has the same group IDs for two tracks in its cache or in the upstream wire, it considers they are common group boundaries (and if not, then it is a matter for the Subscriber).\n\n",
      "createdAt": "2026-02-17T22:21:46Z",
      "updatedAt": "2026-02-17T22:21:46Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 7,
      "id": "I_kwDOROSEss7rvGr2",
      "title": "Timer-based algo would need more details",
      "url": "https://github.com/wilaw/dts4moq/issues/7",
      "state": "OPEN",
      "author": "gwendalsimon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The algorithm is not completely clear at the Relay side.\n- Is the bullet 3 for the initialization only? \"_When the first Object 0 of new Group N of track T arrives at the relay_\". Should the Relay wait for a first objects of Group N of all tracks to arrive? Is there no timer to start?\n-  In bullet 4, \"_ If the track T is not the preferred track, then the relay caches the Group of track T and starts a selection timer_\". It is not clear when the the selection timer starts. Imho, we should start the timer at the reception of the first packet of the first object of group N+1 in any track, i.e. the first packet to arrive for group N+1 among all tracks in the switching set trigger the selection timer. As said in #6, if we wait for the end of the first object's reception, we are prone to jitter due to the different bitrate across tracks and we advantage to the lowest bitrate (which is probably not what we want). If we use the first byte of the first object, we are less sensitive to timer setting issues.\n- In case of gaps, group N+1 should be the next group\n- If we finish the transmission of Group N before starting sending the group N+1 (a.k.a. the next group), then we should restrict the approach to ascending order\n- The end of the timer may cause problem if the tracks have only *some* group boundaries. It is said that \"_If Group N of the preferred track has not arrived by the time the selection timer reaches the selection time limit, then the relay selects a new preferred track [...]_\". Let's say that the preferred track A has groups 30, 35, 40 ... and track B has groups 30, 31, 32, 33, 34, 35, 36, ... At the end of Track B's group 30 (or beginning of group 31), the timer would be triggered, which would cause the Track A to be disqualified. Does the Relay stop the delivery of Track A or should it continue the Group 30? If so, what happens at the time of group 35 (track A has been disqualified for 31, 32, 33, 34)?\n",
      "createdAt": "2026-02-17T22:47:09Z",
      "updatedAt": "2026-02-17T22:47:09Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 8,
      "id": "I_kwDOROSEss7rvKqY",
      "title": "lag behind live and cache",
      "url": "https://github.com/wilaw/dts4moq/issues/8",
      "state": "OPEN",
      "author": "gwendalsimon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "During congestion, the Subscriber lags behind live. It is expected to be less an issue in this adaptive mechanism, but it can still happen. In case the Relay has received several new groups for some tracks, and it cached these groups, should it still refer to the timer result to identify which tracks are qualified for selection?\n\nFor example, say that the Relay just finished transmission of group 30. It has in its cache\nTrack A groups 31, 32, 33. For each of these groups, Track A was the first track to trigger the timer.\nTrack B groups 31 (arrived before timer expiration), 32 (arrived after expiration), and 33 (arrived before expiration). Track B is the preferred track.\n\nShould the Relay switch to track A for group 31 and back to track B at 32?",
      "createdAt": "2026-02-17T22:52:45Z",
      "updatedAt": "2026-02-17T22:52:45Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 9,
      "id": "I_kwDOROSEss7r00RX",
      "title": "too many subscriptions in a switching set",
      "url": "https://github.com/wilaw/dts4moq/issues/9",
      "state": "OPEN",
      "author": "gwendalsimon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I am not a fan of forcing the Relay to subscribe to many tracks while it only forwards one track downstream. In case of large switching sets, it is a significant burden at the Relay. Furthermore, 99% of the time, Subscribers stick to the highest track, so I hope that the developed clients will not subscribe to all tracks in the altGroup, but only to the subset of tracks that are likely to be used, e.g. the top one (likely to be the preferred one), the second top track (in case of a slight drop of connection) and the lowest (one\u00a0in case of disaster). \n\nThe dynamic management of switching sets is a great vehicle to save resources at the Relay, but it is in the hand of the Subscriber.\n\nShould we add a mechanism such that\n- the Relay declares the maximum number of concurrent subscriptions it can handle in a switching set?\n- the Relay rejects a subscription for a switching set because it is above its capacity?   ",
      "createdAt": "2026-02-18T08:01:33Z",
      "updatedAt": "2026-02-18T08:01:33Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 10,
      "id": "I_kwDOROSEss7sNyKQ",
      "title": "First preferred track",
      "url": "https://github.com/wilaw/dts4moq/issues/10",
      "state": "OPEN",
      "author": "gwendalsimon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The text says that (in the third bullet) that \"_When the first Object 0 of new Group N of track T arrives at the relay, the relay selects the preferred track to forward from the switching set. The preferred track is the track with the highest throughput threshold smaller than or equal to the current throughput estimate._\" I think it is for the first choice of preferred track. However, the Relay does not know the current throughput estimate (unless it already has a downstream connection to the same Subscriber).\n\nIt could be possible to let the Subscriber indicate the preferred track in the Switching-Set-Assignment with a flag \"default-preferred-track\" which says that the subscription is about the track that should be chosen first at the activation.\nif several tracks are noted as preferred one, then the last one is chosen.\nIt no track is noted as preferred one, then the Relay chooses any of them.",
      "createdAt": "2026-02-19T13:35:24Z",
      "updatedAt": "2026-02-19T13:35:24Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOROSEss7D-mFA",
      "title": "Fixes minor typos",
      "url": "https://github.com/wilaw/dts4moq/pull/1",
      "state": "CLOSED",
      "author": "zafergurel",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2026-02-16T01:22:48Z",
      "updatedAt": "2026-02-16T01:31:38Z",
      "baseRepository": "wilaw/dts4moq",
      "baseRefName": "main",
      "baseRefOid": "8f01b005a401ef0857fa326001689653b8a59691",
      "headRepository": "zafergurel/dts4moq",
      "headRefName": "main",
      "headRefOid": "8f01b005a401ef0857fa326001689653b8a59691",
      "closedAt": "2026-02-16T01:31:38Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 4,
      "id": "PR_kwDOROSEss7D-rsM",
      "title": "Fixes some minor types",
      "url": "https://github.com/wilaw/dts4moq/pull/4",
      "state": "OPEN",
      "author": "zafergurel",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2026-02-16T01:35:54Z",
      "updatedAt": "2026-02-16T01:35:54Z",
      "baseRepository": "wilaw/dts4moq",
      "baseRefName": "main",
      "baseRefOid": "8f01b005a401ef0857fa326001689653b8a59691",
      "headRepository": "zafergurel/dts4moq",
      "headRefName": "fix/typos",
      "headRefOid": "c3676ccc3d3513d077abd62b6a5e74a30fd623f7",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}